{"version":3,"sources":["../../src/model/Type.js"],"names":["ObjectWrapper","require","extend","Variable","Type","options","prototype","constructor","call","visualType","superType","undefined","capabilities","variableReferences","Object","create","getDefaultValue","wrappedObj","defaultValue","getSuperType","length","isAbstract","getVisualType","extendApi","extensionObj","push","capabilityId","hasCapability","i","addVariableReference","v","getVariableReferences","getPath","parent","typeOf","type","match","superTypes","module","exports"],"mappings":";;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAMA,aAAa,GAAGC,OAAO,CAAC,iBAAD,CAA7B;;AACA,IAAMC,MAAM,GAAGD,OAAO,CAAC,iBAAD,CAAP,CAA2BC,MAA1C;;AACA,IAAMC,QAAQ,GAAGF,OAAO,CAAC,YAAD,CAAP,WAAjB;;AAEA,SAASG,IAAT,CAAeC,OAAf,EAAwB;AACtBL,EAAAA,aAAa,CAACM,SAAd,CAAwBC,WAAxB,CAAoCC,IAApC,CAAyC,IAAzC,EAA+CH,OAA/C;AACA,OAAKI,UAAL,GAAkBJ,OAAO,CAACI,UAA1B;AACA,OAAKC,SAAL,GAAkBL,OAAO,CAACK,SAAR,IAAqBC,SAAtB,GAAmCN,OAAO,CAACK,SAA3C,GAAuD,EAAxE;AACA,OAAKE,YAAL,GAAoB,EAApB;AACA,OAAKC,kBAAL,GAA0B,EAA1B;AACD;;AAEDT,IAAI,CAACE,SAAL,GAAiBQ,MAAM,CAACC,MAAP,CAAcf,aAAa,CAACM,SAA5B,CAAjB;AACAF,IAAI,CAACE,SAAL,CAAeC,WAAf,GAA6BH,IAA7B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAA,IAAI,CAACE,SAAL,CAAeU,eAAf,GAAiC,YAAY;AAC3C,SAAO,KAAKC,UAAL,CAAgBC,YAAvB;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAd,IAAI,CAACE,SAAL,CAAea,YAAf,GAA8B,YAAY;AACxC,MAAIT,SAAS,GAAG,KAAKA,SAArB;;AAEA,MAAIA,SAAS,IAAIC,SAAb,IAA0B,KAAKD,SAAL,CAAeU,MAAf,IAAyB,CAAvD,EAA0D;AACxDV,IAAAA,SAAS,GAAGA,SAAS,CAAC,CAAD,CAArB;AACD;;AAED,SAAOA,SAAP;AACD,CARD;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAN,IAAI,CAACE,SAAL,CAAee,UAAf,GAA4B,YAAY;AACtC,SAAO,KAAKJ,UAAL,YAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAb,IAAI,CAACE,SAAL,CAAegB,aAAf,GAA+B,YAAY;AACzC,SAAO,KAAKb,UAAZ;AACD,CAFD;AAKA;AACA;AACA;AACA;AACA;;;AACAL,IAAI,CAACE,SAAL,CAAeiB,SAAf,GAA2B,UAAUC,YAAV,EAAwB;AACjDtB,EAAAA,MAAM,CAAC,IAAD,EAAOsB,YAAP,CAAN;AACA,OAAKZ,YAAL,CAAkBa,IAAlB,CAAuBD,YAAY,CAACE,YAApC;AACD,CAHD;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAtB,IAAI,CAACE,SAAL,CAAeqB,aAAf,GAA+B,UAAUD,YAAV,EAAwB;AACrD,MAAIC,aAAa,GAAG,KAApB;AACA,MAAIf,YAAY,GAAG,KAAKA,YAAxB;;AAEA,OAAK,IAAIgB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGhB,YAAY,CAACQ,MAAjC,EAAyCQ,CAAC,EAA1C,EAA8C;AAC5C,QAAIhB,YAAY,CAACgB,CAAD,CAAZ,KAAoBF,YAAxB,EAAsC;AACpCC,MAAAA,aAAa,GAAG,IAAhB;AACD;AACF;;AAED,SAAOA,aAAP;AACD,CAXD;AAaA;AACA;AACA;AACA;;;AACAvB,IAAI,CAACE,SAAL,CAAeuB,oBAAf,GAAsC,UAAUC,CAAV,EAAa;AACjD,OAAKjB,kBAAL,CAAwBY,IAAxB,CAA6BK,CAA7B;AACD,CAFD;AAIA;AACA;AACA;AACA;;;AACA1B,IAAI,CAACE,SAAL,CAAeyB,qBAAf,GAAuC,YAAY;AACjD,SAAO,KAAKlB,kBAAZ;AACD,CAFD;;AAIAT,IAAI,CAACE,SAAL,CAAe0B,OAAf,GAAyB,YAAY;AACnC,MAAI,KAAKC,MAAL,IAAetB,SAAf,GAA2B,KAAKsB,MAAL,YAAuB9B,QAAtD,EAAgE;AAC9D;AACA,WAAO,KAAK8B,MAAL,CAAYD,OAAZ,EAAP;AACD,GAHD,MAGO;AACL,WAAOhC,aAAa,CAACM,SAAd,CAAwB0B,OAAxB,CAAgCxB,IAAhC,CAAqC,IAArC,CAAP;AACD;AACF,CAPD;;AASAJ,IAAI,CAACE,SAAL,CAAe4B,MAAf,GAAwB,UAAUC,IAAV,EAAe;AACrC,MAAIC,KAAK,GAAG,KAAZ;;AAEA,MAAID,IAAI,CAACH,OAAL,MAAkB,KAAKA,OAAL,EAAtB,EAAqC;AACnC;AACAI,IAAAA,KAAK,GAAG,IAAR;AACD,GAHD,MAGO;AACL;AACA,QAAIC,UAAU,GAAGF,IAAI,CAACzB,SAAtB;;AAEA,SAAK,IAAIkB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGS,UAAU,CAACjB,MAA/B,EAAuCQ,CAAC,EAAxC,EAA4C;AAC1CQ,MAAAA,KAAK,GAAG,KAAKF,MAAL,CAAYG,UAAU,CAACT,CAAD,CAAtB,CAAR;;AACA,UAAIQ,KAAJ,EAAU;AACR;AACD;AACF;AACF;;AAED,SAAOA,KAAP;AACD,CAnBD,C,CAqBA;;;AACAhC,IAAI,WAAJ,GAAeA,IAAf;AACAkC,MAAM,CAACC,OAAP,GAAiBnC,IAAjB","sourcesContent":["\n\n/**\n * Client class use to represent a simple type.\n *\n * @module model/Type\n * @author Giovanni Idili\n * @author Matteo Cantarelli\n */\nconst ObjectWrapper = require('./ObjectWrapper');\nconst extend = require('../common/Utils').extend;\nconst Variable = require('./Variable').default;\n\nfunction Type (options) {\n  ObjectWrapper.prototype.constructor.call(this, options);\n  this.visualType = options.visualType;\n  this.superType = (options.superType != undefined) ? options.superType : [];\n  this.capabilities = [];\n  this.variableReferences = [];\n}\n\nType.prototype = Object.create(ObjectWrapper.prototype);\nType.prototype.constructor = Type;\n\n/**\n * Gets the default value for this type\n *\n * @command Type.getDefaultValue()\n *\n * @returns {Object} - Default value\n *\n */\nType.prototype.getDefaultValue = function () {\n  return this.wrappedObj.defaultValue;\n};\n\n/**\n * Gets the super type for this type\n *\n * @command Type.getSuperType()\n *\n * @returns {List<Type>} - Super type\n *\n */\nType.prototype.getSuperType = function () {\n  var superType = this.superType;\n\n  if (superType != undefined && this.superType.length == 1) {\n    superType = superType[0];\n  }\n\n  return superType;\n};\n\n/**\n * Check if the type is abstract\n *\n * @command Type.isAbstract()\n *\n * @returns {Boolean} - Boolean indicating if the type is abstract\n *\n */\nType.prototype.isAbstract = function () {\n  return this.wrappedObj.abstract;\n};\n\n/**\n * Gets the visual type for this type if any\n *\n * @command Type.getVisualType()\n *\n * @returns {Type} - Super type\n *\n */\nType.prototype.getVisualType = function () {\n  return this.visualType;\n};\n\n\n/**\n * Extends with methods from another object\n *\n * @command Type.extendApi(extensionObj)\n */\nType.prototype.extendApi = function (extensionObj) {\n  extend(this, extensionObj);\n  this.capabilities.push(extensionObj.capabilityId);\n};\n\n/**\n * Checks if the instance has a given capability\n *\n * @command Type.hasCapability(capabilityId)\n *\n * @returns {Boolean}\n */\nType.prototype.hasCapability = function (capabilityId) {\n  var hasCapability = false;\n  var capabilities = this.capabilities;\n\n  for (var i = 0; i < capabilities.length; i++) {\n    if (capabilities[i] === capabilityId) {\n      hasCapability = true;\n    }\n  }\n\n  return hasCapability;\n};\n\n/**\n *\n * @param v\n */\nType.prototype.addVariableReference = function (v) {\n  this.variableReferences.push(v);\n};\n\n/**\n *\n * @returns {Array}\n */\nType.prototype.getVariableReferences = function () {\n  return this.variableReferences;\n};\n\nType.prototype.getPath = function () {\n  if (this.parent != undefined & this.parent instanceof Variable) {\n    // if this is an anonymous type it doesn't have an id, hence we skip it\n    return this.parent.getPath();\n  } else {\n    return ObjectWrapper.prototype.getPath.call(this);\n  }\n};\n\nType.prototype.typeOf = function (type){\n  var match = false;\n\n  if (type.getPath() == this.getPath()){\n    // check if it's the same type\n    match = true;\n  } else {\n    // recurse on parents and figure out if there is a type in the inheritance chain\n    var superTypes = type.superType;\n\n    for (var i = 0; i < superTypes.length; i++) {\n      match = this.typeOf(superTypes[i]);\n      if (match){\n        break;\n      }\n    }\n  }\n\n  return match;\n};\n\n// Compatibility with new imports and old require syntax\nType.default = Type;\nmodule.exports = Type;\n\n"],"file":"Type.js"}